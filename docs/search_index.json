[
["index.html", "Prácticas de Tecnologías de Gestión de Datos Prólogo", " Prácticas de Tecnologías de Gestión de Datos Rubén F. Casal (ruben.fcasal@udc.es), Guillermo López Taboada (guillermo.lopez.taboada@udc.es) 2019-09-10 Prólogo Este libro contiene algunas de las prácticas de la asignatura de Tecnologías de Gestión de Datos del Máster interuniversitario en Técnicas Estadísticas). Este libro ha sido escrito en R-Markdown empleando el paquete bookdown y está disponible en el repositorio Github: rubenfcasal/simbook. Para generar el libro (compilar) puede ser recomendable instalar la última versión de RStudio y la versión de desarrollo de bookdown disponible en Github: devtools::install_github(&quot;rstudio/bookdown&quot;) Este obra está bajo una licencia de Creative Commons Reconocimiento-NoComercial-SinObraDerivada 4.0 Internacional (espero poder liberarlo bajo una licencia menos restrictiva más adelante…). "],
["introduccion-a-las-tecnologias-de-gestion-de-datos.html", "Capítulo 1 Introducción a las Tecnologías de Gestión de Datos 1.1 Introducción 1.2 Contenidos 1.3 Planificación 1.4 Fuentes de información:", " Capítulo 1 Introducción a las Tecnologías de Gestión de Datos 1.1 Introducción La información relevante de la materia está disponible en la guía docente y la ficha de la asignatura En particular, los resultados de aprendizaje son: Manejar de forma autónoma y solvente el software necesario para acceder a conjuntos de datos en entornos profesionales y/o en la nube. Saber gestionar conjuntos de datos masivos en un entorno multidisciplinar que permita la participación en proyectos profesionales complejos que requieran el uso de técnicas estadísticas. Saber relacionar el software de diseño y gestión de bases de datos con el específicamente implementado para el análisis de datos. 1.2 Contenidos Introducción al lenguaje SQL Bases de datos relacionales Sintaxis SQL Conexión con bases de datos desde R Introducción a tecnologías NoSQL Conceptos y tipos de bases de datos NoSQL (documental, columnar, clave/valor y de grafos) Conexión de R a NoSQL Tecnologías para el tratamiento de datos masivos Tecnologías Big Data (Hadoop, Spark, Hive, Rspark, Sparklyr) Visualización y generación de cuadros de mando Introducción al análisis de datos masivos. 1.3 Planificación Clase 1 (12/9): Seminario R: Manipulación de datos con el paquete básico de R Clase 2 (19/9): Tema 1: Conceptos de bases de datos Clase 3 (26/9): Tema 1: Introducción a SQL Clase 4 (3/10): Seminario dplyr Clase 5 (10/10): Tema 1: Ejercicios prácticos de Entidad-relación y SQL Clase 6 (17/10): Tema 1: Continuación de ejercicios prácticos SQL Clase 7 (24/10): Tema 2: Introducción a NoSQL Clase 8 (31/10): Tema 2: Ejercicios prácticos de NoSQL Clase 9 (7/11): Tema 3: Ecosistema Big Data (Hadoop, Spark) Clase 10 (14/11): Tema 3: Tecnologías Big Data (Rspark/sparklyr) Clase 11 (21/11): Seminario visualización con power BI Clase 12 (28/11): Seminario machine learning CESGA/localhost Clase 13 (5/12): Tema 3: Introducción al análisis de datos masivos Clase 14 (12/12): Seminario conceptos avanzados de R Clase 15 (19/12): Seminario aplicaciones Big Data en investigación e industria 1.3.1 Evaluación Examen (60%): El examen de la materia evaluará los siguientes aspectos: Conceptos de la materia: Dominio de los conocimientos teóricos y operativos de la materia. Asimilación práctica de materia: Asimilación y comprensión de los conocimientos teóricos y operativos de la materia. Prácticas de laboratorio (30%): Evaluación de las prácticas de laboratorio desarrolladas por los estudiantes. Trabajos tutelados (10%): Evaluación de los trabajos tutelados desarrollados por los estudiantes. 1.3.1.1 Observaciones sobre la evaluación: Las prácticas de laboratorio se realizarán en grupos de 2. Para poder aprobar la asignatura en la primera oportunidad será necesario obtener como mínimo el 30% de la nota máxima de la suma de las prácticas de laboratorio y trabajos tutelados e, igualmente, el 30% de la nota máxima final de la Prueba mixta (examen), y tener una nota total (prácticas más trabajos tutelados más prueba mixta) igual o superior al 50% de la nota máxima. En la segunda oportunidad solamente se podrá recuperar la nota del examen. Las notas de prácticas y de trabajos tutelados serán las obtenidas durante el curso. Para los alumnos que utilicen la oportunidad adelantada de diciembre se utilizarán las notas de prácticas y trabajos tutelados que obtuvieran en su último curso. En esta oportunidad solo será necesario para aprobar obtener una nota total igual o superior al 50% de la nota máxima. Una vez que un estudiante es evaluado en una práctica de laboratorio o en un trabajo tutelado implica que será calificado. Por tanto, la calificación “No Presentado” no es posible una vez que una práctica/trabajo ha sido evaluada. 1.4 Fuentes de información: 1.4.1 Básica Daroczi, G. (2015). Mastering Data Analysis with R. Packt Publishing Grolemund, G. y Wickham, H. (2016). R for Data Science. https://r4ds.had.co.nz/ &amp; O’Reilly Silberschatz, A., Korth, H. y Sudarshan, S. (2014). Fundamentos de Bases de Datos. Mc Graw Hill Rubén Fernández Casal (2019). Ayuda y Recursos para el Aprendizaje de R. https://rubenfcasal.github.io/post/ayuda-y-recursos-para-el-aprendizaje-de-r/ 1.4.2 Complementaria: Wes McKinney (2017). Python for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython. O’Reilly (2ª ed.) Tom White (2015). Hadoop: The Definitive Guide. O’Reilly (4ª ed.) Alex Holmes (2014). Hadoop in practice. Manning (2ª ed.) Centro de Supercomputación de Galicia (2019). Servicio de Big Data del CESGA. https://bigdata.cesga.es/ "],
["introduccion-al-lenguaje-sql.html", "Capítulo 2 Introducción al lenguaje SQL 2.1 Bases de Datos Relacionales 2.2 Sintaxis SQL 2.3 Conexión con bases de datos desde R", " Capítulo 2 Introducción al lenguaje SQL Los sistemas de información gestionan repositorios de información en múltiples formatos, siendo el más popular las bases de datos relacionales a las que se accede mediante SQL (Structured Query Language) 2.1 Bases de Datos Relacionales 2.1.1 Definiciones Dominio: contexto (organización, empresa, evento…) objeto de gestión de la información. Dato: hecho con significado implícito, registable, relevante en un determinado dominio. Base de datos: colección de datos de un determinado dominio relacionados entre sí, organizados de forma que sea posible manipularlos y recuperarlos de forma eficiente. Sistema de Gestión de Bases de Datos (SGBD) (en inglés RDBMS, Relational Database Management System): software que permite a los usuarios crear y manipular bases de datos mediante operaciones CRUD: Crear / Insertar Datos (Create) Consultar / Leer (Read) Actualizar / Modificar (Update) Eliminar (Delete) Modelo de datos: abstracción conceptual que propone una manera de organizar y manipular los datos. Definido mediante: Estructura: elementos para organizar datos Integridad: reglas para relaciones los elementos Manipulación: operaciones sobre los datos adaptadas a la estructura y reglas Modelo de datos conceptual Entidad Relación (entidades, relaciones, atributos) Modelo de datos lógico o de representación (modelo relacional de Codd) Datos en relaciones (tablas) Base matemática formal Flexible Modelo de datos físico (tal y como se almacenan los datos) Una fila de la tabla (relación) es una tupla y una columna un atributo. Una base de datos es un conjunto de tablas (al menos una). La tabla no es una relación porque la relación es un conjunto sin orden y una tabla puede tener filas repetidas y tiene orden. Esquema: estructura de la base de datos Estado: contenido de la base de datos Restricción de integridad: regla que debe cumplir la información registrada en la base de datos para garantizar la integridad de la información. Cualquier Base de Datos basada en el modelo relacional ha de cumplir como mínimo estas restricciones (además de las propias del dominio): Restricción de dominio: el valor de cada atributo debe de ser único (teléfono, no valor único), no descomponible (nombre completo descomponible en nombre y apellidos, domicilio en calle, CP, localidad, etc…) Una relación es un conjunto de tuplas, por tanto todas las tuplas son distintas. Una superclave es un subconjunto de atributos tal que no existen dos tuplas con la misma superclave. Ejercicio. En la relación Empleado(dni, nombre, apellidos, email) ¿cuántas superclaves existen? Una clave candidata es una superclave mínima (superclave mínima es la clave a la que no se le puede eliminar un atributo). ¿Cuántas claves candidatas hay en el ejemplo anterior? Clave primaria es la clave candidata que elegimos que identificar de forma unívoca las tuplas de una relación. Restricción de integridad de entidad: Ningún valor de la clave primaria puede ser un valor nulo. Clave foránea es un conjunto de atributos de una relación R_1 que, para cada tupla, identifican a otra tupla de una relación R_2 con la que está relacionada. La Restricción de integridad referencial nos dice que la clave foránea ha de corresponderse con la clave primaria de R_2, y si la clave foránea no es nula ha de refir a una tupla en R_2. Si borramos/actualizamos un valor de clave foránea podemos: (a) prohibir el cambio, o (b) poner a nulo la clave foránea (borrado) o propogar el cambio (modificación). Ventajas de SGBD: Administración centralizada de los datos (por un administrador en un servidor/plataforma central que evita la información en silos -redundante/inconsistente) Desacoplado del almacenamiento físico de los datos (no es necesario conocerlo) Simplicidad de acceso (ODBC + SQL, lenguaje declarativo) Control de integridad (restricciones genéricas, integridad de entidad y referencial, de dominio, y las del dominio en software) Control de acceso concurrente (evita inconsistencia) Seguridad (autenticación, roles de acceso) Recuperación ante fallos (backup, logs y transacciones -rollback-) 2.2 Sintaxis SQL A continuación 27 clásulas SQL básicas 2.2.1 Extracción SQL (11 statements) SELECT column1, column2....columnN FROM table_name; SELECT DISTINCT column1, column2....columnN FROM table_name; SELECT column1, column2....columnN FROM table_name WHERE CONDITION; SELECT column1, column2....columnN FROM table_name WHERE CONDITION-1 {AND|OR} CONDITION-2; SELECT column1, column2....columnN FROM table_name WHERE column_name IN (val-1, val-2,...val-N); SELECT column1, column2....columnN FROM table_name WHERE column_name BETWEEN val-1 AND val-2; SELECT column1, column2....columnN FROM table_name WHERE column_name LIKE { PATTERN }; SELECT column1, column2....columnN FROM table_name WHERE CONDITION ORDER BY column_name {ASC|DESC}; SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name; SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); 2.2.2 Crear/Actualizar/Borrar tablas SQL (8 statements) CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); DROP TABLE table_name; CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...columnN); ALTER TABLE table_name DROP INDEX index_name; DESC table_name; TRUNCATE TABLE table_name; ALTER TABLE table_name {ADD|DROP|MODIFY} column_name {data_ype}; ALTER TABLE table_name RENAME TO new_table_name; 2.2.3 Añadir/Actualizar/Borrar tuplas en SQL (3 statements) INSERT INTO table_name( column1, column2....columnN) VALUES ( value1, value2....valueN); UPDATE table_name SET column1 = value1, column2 = value2....columnN=valueN [ WHERE CONDITION ]; DELETE FROM table_name WHERE {CONDITION}; 2.2.4 Gestión Bases de Datos (5 statements) CREATE DATABASE database_name; DROP DATABASE database_name; USE database_name; COMMIT; ROLLBACK; 2.2.5 Ejemplos de consultas SQL SELECT Nombre, Apellido1, Apellido2, Municipio, Provincia FROM Cliente WHERE Municipio = &#39;Lugo&#39; ORDER BY Apellido1 INSERT Proveedor(Nombre, PersonaContacto, Ciudad, País) VALUES (&#39;Café Candelas&#39;, &#39;Ivana Candelas&#39;, &#39;Lugo&#39;, &#39;España&#39;) UPDATE Pedidos SET Cantidad = 2 WHERE IdProducto = 963 DELETE Cliente WHERE Email = &#39;alexandregb@gmail.com&#39; 2.3 Conexión con bases de datos desde R 2.3.1 Introducción a SQL en R SQL se usa para manipular datos dentro de una base de datos. Si la base de datos no es muy grande se puede cargar toda en un data.frame. No obstante, por escalabilidad y offloading de la carga de trabajo al servidor SGBD utilizaremos SQL. Existen varios SGBD (SQLite, Microsoft SQL Server, PostgreSQL, etc) los cuales comparten el soporte de SQL (en concreto ANSI SQL) aunque cada gestor extiende SQL de formas sutiles buscando minar cierta portabilidad de código (vendor-locking). En efecto, un código SQL desarrollado para SQLite es probable que falle con MySQL aunque tras aplicar ligeras modificaciones ya funcionará. Asimismo el mecanismo de conexión, configuración, rendimiento y operación suele diferir entre SGBD. A continuación se lista una serie de paquetes utilizados en el acceso a los datos, lo que suele ser el principal esfuerzo a realizar cuando se trabaja con SGBD: DBI RODBC dbConnect RSQLite RMySQL RPostgreSQL 2.3.2 El paquete sqldf A continuación se presenta una serie de ejercicios con la sintaxis de SQL operando sobre un data.frame con el paquete sqldf. Esto inicialmente no incluye los detalles de conectarse a un SGBD, ni modificar los datos, solamente el uso de SQL para extraer datos con el objetivo de ser analizados en R. library(sqldf) sqldf(&#39;SELECT age, circumference FROM Orange WHERE Tree = 1 ORDER BY circumference ASC&#39;) ## age circumference ## 1 118 30 ## 2 484 58 ## 3 664 87 ## 4 1004 115 ## 5 1231 120 ## 6 1372 142 ## 7 1582 145 2.3.3 SQL Queries El comando inicial es SELECT. SQL no es case-sensitive, por lo que esto va a funcionar: sqldf(&quot;SELECT * FROM iris&quot;) sqldf(&quot;select * from iris&quot;) pero lo siguiente no va a funcionar (a menos que tengamos un objeto IRIS: sqldf(&quot;SELECT * FROM IRIS&quot;) La sintaxis básica de SELECT es: SELECT variable1, variable2 FROM data 2.3.3.1 Asterisco/Wildcard Lo extrae todo bod2 &lt;- sqldf(&#39;SELECT * FROM BOD&#39;) 2.3.3.2 Limit Limita el número de resultados sqldf(&#39;SELECT * FROM iris LIMIT 5&#39;) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa 2.3.3.3 Order By Ordena las variables ORDER BY var1 {ASC/DESC}, var2 {ASC/DESC} sqldf(&quot;SELECT * FROM Orange ORDER BY age ASC, circumference DESC LIMIT 5&quot;) ## Tree age circumference ## 1 2 118 33 ## 2 4 118 32 ## 3 1 118 30 ## 4 3 118 30 ## 5 5 118 30 2.3.3.4 Where Sentencias condicionales, donde se puede incorporar operadores lógicos AND y OR, expresando el orden de evaluación con paréntesis en caso de ser necesario. sqldf(&#39;SELECT demand FROM BOD WHERE Time &lt; 3&#39;) ## demand ## 1 8.3 ## 2 10.3 sqldf(&#39;SELECT * FROM rock WHERE (peri &gt; 5000 AND shape &lt; .05) OR perm &gt; 1000&#39;) ## area peri shape perm ## 1 5048 941.543 0.328641 1300 ## 2 1016 308.642 0.230081 1300 ## 3 5605 1145.690 0.464125 1300 ## 4 8793 2280.490 0.420477 1300 Y extendiendo su uso con IN o LIKE (es último sólo con %), pudiendo aplicárseles el NOT: sqldf(&#39;SELECT * FROM BOD WHERE Time IN (1,7)&#39;) ## Time demand ## 1 1 8.3 ## 2 7 19.8 sqldf(&#39;SELECT * FROM BOD WHERE Time NOT IN (1,7)&#39;) ## Time demand ## 1 2 10.3 ## 2 3 19.0 ## 3 4 16.0 ## 4 5 15.6 sqldf(&#39;SELECT * FROM chickwts WHERE feed LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 179 horsebean ## 2 160 horsebean ## 3 136 horsebean ## 4 227 horsebean ## 5 217 horsebean sqldf(&#39;SELECT * FROM chickwts WHERE feed NOT LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 309 linseed ## 2 229 linseed ## 3 181 linseed ## 4 141 linseed ## 5 260 linseed "],
["introduccion-al-lenguaje-sql-1.html", "Capítulo 3 Introducción al lenguaje SQL 3.1 Bases de Datos Relacionales 3.2 Sintaxis SQL 3.3 Conexión con bases de datos desde R", " Capítulo 3 Introducción al lenguaje SQL Los sistemas de información gestionan repositorios de información en múltiples formatos, siendo el más popular las bases de datos relacionales a las que se accede mediante SQL (Structured Query Language) 3.1 Bases de Datos Relacionales 3.1.1 Definiciones Dominio: contexto (organización, empresa, evento…) objeto de gestión de la información. Dato: hecho con significado implícito, registable, relevante en un determinado dominio. Base de datos: colección de datos de un determinado dominio relacionados entre sí, organizados de forma que sea posible manipularlos y recuperarlos de forma eficiente. Sistema de Gestión de Bases de Datos (SGBD) (en inglés RDBMS, Relational Database Management System): software que permite a los usuarios crear y manipular bases de datos mediante operaciones CRUD: Crear / Insertar Datos (Create) Consultar / Leer (Read) Actualizar / Modificar (Update) Eliminar (Delete) Modelo de datos: abstracción conceptual que propone una manera de organizar y manipular los datos. Definido mediante: Estructura: elementos para organizar datos Integridad: reglas para relaciones los elementos Manipulación: operaciones sobre los datos adaptadas a la estructura y reglas Modelo de datos conceptual Entidad Relación (entidades, relaciones, atributos) Modelo de datos lógico o de representación (modelo relacional de Codd) Datos en relaciones (tablas) Base matemática formal Flexible Modelo de datos físico (tal y como se almacenan los datos) Una fila de la tabla (relación) es una tupla y una columna un atributo. Una base de datos es un conjunto de tablas (al menos una). La tabla no es una relación porque la relación es un conjunto sin orden y una tabla puede tener filas repetidas y tiene orden. Esquema: estructura de la base de datos Estado: contenido de la base de datos Restricción de integridad: regla que debe cumplir la información registrada en la base de datos para garantizar la integridad de la información. Cualquier Base de Datos basada en el modelo relacional ha de cumplir como mínimo estas restricciones (además de las propias del dominio): Restricción de dominio: el valor de cada atributo debe de ser único (teléfono, no valor único), no descomponible (nombre completo descomponible en nombre y apellidos, domicilio en calle, CP, localidad, etc…) Una relación es un conjunto de tuplas, por tanto todas las tuplas son distintas. Una superclave es un subconjunto de atributos tal que no existen dos tuplas con la misma superclave. Ejercicio. En la relación Empleado(dni, nombre, apellidos, email) ¿cuántas superclaves existen? Una clave candidata es una superclave mínima (superclave mínima es la clave a la que no se le puede eliminar un atributo). ¿Cuántas claves candidatas hay en el ejemplo anterior? Clave primaria es la clave candidata que elegimos que identificar de forma unívoca las tuplas de una relación. Restricción de integridad de entidad: Ningún valor de la clave primaria puede ser un valor nulo. Clave foránea es un conjunto de atributos de una relación R_1 que, para cada tupla, identifican a otra tupla de una relación R_2 con la que está relacionada. La Restricción de integridad referencial nos dice que la clave foránea ha de corresponderse con la clave primaria de R_2, y si la clave foránea no es nula ha de refir a una tupla en R_2. Si borramos/actualizamos un valor de clave foránea podemos: (a) prohibir el cambio, o (b) poner a nulo la clave foránea (borrado) o propogar el cambio (modificación). Ventajas de SGBD: Administración centralizada de los datos (por un administrador en un servidor/plataforma central que evita la información en silos -redundante/inconsistente) Desacoplado del almacenamiento físico de los datos (no es necesario conocerlo) Simplicidad de acceso (ODBC + SQL, lenguaje declarativo) Control de integridad (restricciones genéricas, integridad de entidad y referencial, de dominio, y las del dominio en software) Control de acceso concurrente (evita inconsistencia) Seguridad (autenticación, roles de acceso) Recuperación ante fallos (backup, logs y transacciones -rollback-) 3.2 Sintaxis SQL A continuación 27 clásulas SQL básicas 3.2.1 Extracción SQL (11 statements) SELECT column1, column2....columnN FROM table_name; SELECT DISTINCT column1, column2....columnN FROM table_name; SELECT column1, column2....columnN FROM table_name WHERE CONDITION; SELECT column1, column2....columnN FROM table_name WHERE CONDITION-1 {AND|OR} CONDITION-2; SELECT column1, column2....columnN FROM table_name WHERE column_name IN (val-1, val-2,...val-N); SELECT column1, column2....columnN FROM table_name WHERE column_name BETWEEN val-1 AND val-2; SELECT column1, column2....columnN FROM table_name WHERE column_name LIKE { PATTERN }; SELECT column1, column2....columnN FROM table_name WHERE CONDITION ORDER BY column_name {ASC|DESC}; SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name; SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); 3.2.2 Crear/Actualizar/Borrar tablas SQL (8 statements) CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); DROP TABLE table_name; CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...columnN); ALTER TABLE table_name DROP INDEX index_name; DESC table_name; TRUNCATE TABLE table_name; ALTER TABLE table_name {ADD|DROP|MODIFY} column_name {data_ype}; ALTER TABLE table_name RENAME TO new_table_name; 3.2.3 Añadir/Actualizar/Borrar tuplas en SQL (3 statements) INSERT INTO table_name( column1, column2....columnN) VALUES ( value1, value2....valueN); UPDATE table_name SET column1 = value1, column2 = value2....columnN=valueN [ WHERE CONDITION ]; DELETE FROM table_name WHERE {CONDITION}; 3.2.4 Gestión Bases de Datos (5 statements) CREATE DATABASE database_name; DROP DATABASE database_name; USE database_name; COMMIT; ROLLBACK; 3.2.5 Ejemplos de consultas SQL SELECT Nombre, Apellido1, Apellido2, Municipio, Provincia FROM Cliente WHERE Municipio = &#39;Lugo&#39; ORDER BY Apellido1 INSERT Proveedor(Nombre, PersonaContacto, Ciudad, País) VALUES (&#39;Café Candelas&#39;, &#39;Ivana Candelas&#39;, &#39;Lugo&#39;, &#39;España&#39;) UPDATE Pedidos SET Cantidad = 2 WHERE IdProducto = 963 DELETE Cliente WHERE Email = &#39;alexandregb@gmail.com&#39; 3.3 Conexión con bases de datos desde R 3.3.1 Introducción a SQL en R SQL se usa para manipular datos dentro de una base de datos. Si la base de datos no es muy grande se puede cargar toda en un data.frame. No obstante, por escalabilidad y offloading de la carga de trabajo al servidor SGBD utilizaremos SQL. Existen varios SGBD (SQLite, Microsoft SQL Server, PostgreSQL, etc) los cuales comparten el soporte de SQL (en concreto ANSI SQL) aunque cada gestor extiende SQL de formas sutiles buscando minar cierta portabilidad de código (vendor-locking). En efecto, un código SQL desarrollado para SQLite es probable que falle con MySQL aunque tras aplicar ligeras modificaciones ya funcionará. Asimismo el mecanismo de conexión, configuración, rendimiento y operación suele diferir entre SGBD. A continuación se lista una serie de paquetes utilizados en el acceso a los datos, lo que suele ser el principal esfuerzo a realizar cuando se trabaja con SGBD: DBI RODBC dbConnect RSQLite RMySQL RPostgreSQL 3.3.2 El paquete sqldf A continuación se presenta una serie de ejercicios con la sintaxis de SQL operando sobre un data.frame con el paquete sqldf. Esto inicialmente no incluye los detalles de conectarse a un SGBD, ni modificar los datos, solamente el uso de SQL para extraer datos con el objetivo de ser analizados en R. library(sqldf) sqldf(&#39;SELECT age, circumference FROM Orange WHERE Tree = 1 ORDER BY circumference ASC&#39;) ## age circumference ## 1 118 30 ## 2 484 58 ## 3 664 87 ## 4 1004 115 ## 5 1231 120 ## 6 1372 142 ## 7 1582 145 3.3.3 SQL Queries El comando inicial es SELECT. SQL no es case-sensitive, por lo que esto va a funcionar: sqldf(&quot;SELECT * FROM iris&quot;) sqldf(&quot;select * from iris&quot;) pero lo siguiente no va a funcionar (a menos que tengamos un objeto IRIS: sqldf(&quot;SELECT * FROM IRIS&quot;) La sintaxis básica de SELECT es: SELECT variable1, variable2 FROM data 3.3.3.1 Asterisco/Wildcard Lo extrae todo bod2 &lt;- sqldf(&#39;SELECT * FROM BOD&#39;) 3.3.3.2 Limit Limita el número de resultados sqldf(&#39;SELECT * FROM iris LIMIT 5&#39;) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa 3.3.3.3 Order By Ordena las variables ORDER BY var1 {ASC/DESC}, var2 {ASC/DESC} sqldf(&quot;SELECT * FROM Orange ORDER BY age ASC, circumference DESC LIMIT 5&quot;) ## Tree age circumference ## 1 2 118 33 ## 2 4 118 32 ## 3 1 118 30 ## 4 3 118 30 ## 5 5 118 30 3.3.3.4 Where Sentencias condicionales, donde se puede incorporar operadores lógicos AND y OR, expresando el orden de evaluación con paréntesis en caso de ser necesario. sqldf(&#39;SELECT demand FROM BOD WHERE Time &lt; 3&#39;) ## demand ## 1 8.3 ## 2 10.3 sqldf(&#39;SELECT * FROM rock WHERE (peri &gt; 5000 AND shape &lt; .05) OR perm &gt; 1000&#39;) ## area peri shape perm ## 1 5048 941.543 0.328641 1300 ## 2 1016 308.642 0.230081 1300 ## 3 5605 1145.690 0.464125 1300 ## 4 8793 2280.490 0.420477 1300 Y extendiendo su uso con IN o LIKE (es último sólo con %), pudiendo aplicárseles el NOT: sqldf(&#39;SELECT * FROM BOD WHERE Time IN (1,7)&#39;) ## Time demand ## 1 1 8.3 ## 2 7 19.8 sqldf(&#39;SELECT * FROM BOD WHERE Time NOT IN (1,7)&#39;) ## Time demand ## 1 2 10.3 ## 2 3 19.0 ## 3 4 16.0 ## 4 5 15.6 sqldf(&#39;SELECT * FROM chickwts WHERE feed LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 179 horsebean ## 2 160 horsebean ## 3 136 horsebean ## 4 227 horsebean ## 5 217 horsebean sqldf(&#39;SELECT * FROM chickwts WHERE feed NOT LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 309 linseed ## 2 229 linseed ## 3 181 linseed ## 4 141 linseed ## 5 260 linseed "],
["introduccion-al-lenguaje-sql-2.html", "Capítulo 4 Introducción al lenguaje SQL 4.1 Bases de Datos Relacionales 4.2 Sintaxis SQL 4.3 Conexión con bases de datos desde R", " Capítulo 4 Introducción al lenguaje SQL Los sistemas de información gestionan repositorios de información en múltiples formatos, siendo el más popular las bases de datos relacionales a las que se accede mediante SQL (Structured Query Language) 4.1 Bases de Datos Relacionales 4.1.1 Definiciones Dominio: contexto (organización, empresa, evento…) objeto de gestión de la información. Dato: hecho con significado implícito, registable, relevante en un determinado dominio. Base de datos: colección de datos de un determinado dominio relacionados entre sí, organizados de forma que sea posible manipularlos y recuperarlos de forma eficiente. Sistema de Gestión de Bases de Datos (SGBD) (en inglés RDBMS, Relational Database Management System): software que permite a los usuarios crear y manipular bases de datos mediante operaciones CRUD: Crear / Insertar Datos (Create) Consultar / Leer (Read) Actualizar / Modificar (Update) Eliminar (Delete) Modelo de datos: abstracción conceptual que propone una manera de organizar y manipular los datos. Definido mediante: Estructura: elementos para organizar datos Integridad: reglas para relaciones los elementos Manipulación: operaciones sobre los datos adaptadas a la estructura y reglas Modelo de datos conceptual Entidad Relación (entidades, relaciones, atributos) Modelo de datos lógico o de representación (modelo relacional de Codd) Datos en relaciones (tablas) Base matemática formal Flexible Modelo de datos físico (tal y como se almacenan los datos) Una fila de la tabla (relación) es una tupla y una columna un atributo. Una base de datos es un conjunto de tablas (al menos una). La tabla no es una relación porque la relación es un conjunto sin orden y una tabla puede tener filas repetidas y tiene orden. Esquema: estructura de la base de datos Estado: contenido de la base de datos Restricción de integridad: regla que debe cumplir la información registrada en la base de datos para garantizar la integridad de la información. Cualquier Base de Datos basada en el modelo relacional ha de cumplir como mínimo estas restricciones (además de las propias del dominio): Restricción de dominio: el valor de cada atributo debe de ser único (teléfono, no valor único), no descomponible (nombre completo descomponible en nombre y apellidos, domicilio en calle, CP, localidad, etc…) Una relación es un conjunto de tuplas, por tanto todas las tuplas son distintas. Una superclave es un subconjunto de atributos tal que no existen dos tuplas con la misma superclave. Ejercicio. En la relación Empleado(dni, nombre, apellidos, email) ¿cuántas superclaves existen? Una clave candidata es una superclave mínima (superclave mínima es la clave a la que no se le puede eliminar un atributo). ¿Cuántas claves candidatas hay en el ejemplo anterior? Clave primaria es la clave candidata que elegimos que identificar de forma unívoca las tuplas de una relación. Restricción de integridad de entidad: Ningún valor de la clave primaria puede ser un valor nulo. Clave foránea es un conjunto de atributos de una relación R_1 que, para cada tupla, identifican a otra tupla de una relación R_2 con la que está relacionada. La Restricción de integridad referencial nos dice que la clave foránea ha de corresponderse con la clave primaria de R_2, y si la clave foránea no es nula ha de refir a una tupla en R_2. Si borramos/actualizamos un valor de clave foránea podemos: (a) prohibir el cambio, o (b) poner a nulo la clave foránea (borrado) o propogar el cambio (modificación). Ventajas de SGBD: Administración centralizada de los datos (por un administrador en un servidor/plataforma central que evita la información en silos -redundante/inconsistente) Desacoplado del almacenamiento físico de los datos (no es necesario conocerlo) Simplicidad de acceso (ODBC + SQL, lenguaje declarativo) Control de integridad (restricciones genéricas, integridad de entidad y referencial, de dominio, y las del dominio en software) Control de acceso concurrente (evita inconsistencia) Seguridad (autenticación, roles de acceso) Recuperación ante fallos (backup, logs y transacciones -rollback-) 4.2 Sintaxis SQL A continuación 27 clásulas SQL básicas 4.2.1 Extracción SQL (11 statements) SELECT column1, column2....columnN FROM table_name; SELECT DISTINCT column1, column2....columnN FROM table_name; SELECT column1, column2....columnN FROM table_name WHERE CONDITION; SELECT column1, column2....columnN FROM table_name WHERE CONDITION-1 {AND|OR} CONDITION-2; SELECT column1, column2....columnN FROM table_name WHERE column_name IN (val-1, val-2,...val-N); SELECT column1, column2....columnN FROM table_name WHERE column_name BETWEEN val-1 AND val-2; SELECT column1, column2....columnN FROM table_name WHERE column_name LIKE { PATTERN }; SELECT column1, column2....columnN FROM table_name WHERE CONDITION ORDER BY column_name {ASC|DESC}; SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name; SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); 4.2.2 Crear/Actualizar/Borrar tablas SQL (8 statements) CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); DROP TABLE table_name; CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...columnN); ALTER TABLE table_name DROP INDEX index_name; DESC table_name; TRUNCATE TABLE table_name; ALTER TABLE table_name {ADD|DROP|MODIFY} column_name {data_ype}; ALTER TABLE table_name RENAME TO new_table_name; 4.2.3 Añadir/Actualizar/Borrar tuplas en SQL (3 statements) INSERT INTO table_name( column1, column2....columnN) VALUES ( value1, value2....valueN); UPDATE table_name SET column1 = value1, column2 = value2....columnN=valueN [ WHERE CONDITION ]; DELETE FROM table_name WHERE {CONDITION}; 4.2.4 Gestión Bases de Datos (5 statements) CREATE DATABASE database_name; DROP DATABASE database_name; USE database_name; COMMIT; ROLLBACK; 4.2.5 Ejemplos de consultas SQL SELECT Nombre, Apellido1, Apellido2, Municipio, Provincia FROM Cliente WHERE Municipio = &#39;Lugo&#39; ORDER BY Apellido1 INSERT Proveedor(Nombre, PersonaContacto, Ciudad, País) VALUES (&#39;Café Candelas&#39;, &#39;Ivana Candelas&#39;, &#39;Lugo&#39;, &#39;España&#39;) UPDATE Pedidos SET Cantidad = 2 WHERE IdProducto = 963 DELETE Cliente WHERE Email = &#39;alexandregb@gmail.com&#39; 4.3 Conexión con bases de datos desde R 4.3.1 Introducción a SQL en R SQL se usa para manipular datos dentro de una base de datos. Si la base de datos no es muy grande se puede cargar toda en un data.frame. No obstante, por escalabilidad y offloading de la carga de trabajo al servidor SGBD utilizaremos SQL. Existen varios SGBD (SQLite, Microsoft SQL Server, PostgreSQL, etc) los cuales comparten el soporte de SQL (en concreto ANSI SQL) aunque cada gestor extiende SQL de formas sutiles buscando minar cierta portabilidad de código (vendor-locking). En efecto, un código SQL desarrollado para SQLite es probable que falle con MySQL aunque tras aplicar ligeras modificaciones ya funcionará. Asimismo el mecanismo de conexión, configuración, rendimiento y operación suele diferir entre SGBD. A continuación se lista una serie de paquetes utilizados en el acceso a los datos, lo que suele ser el principal esfuerzo a realizar cuando se trabaja con SGBD: DBI RODBC dbConnect RSQLite RMySQL RPostgreSQL 4.3.2 El paquete sqldf A continuación se presenta una serie de ejercicios con la sintaxis de SQL operando sobre un data.frame con el paquete sqldf. Esto inicialmente no incluye los detalles de conectarse a un SGBD, ni modificar los datos, solamente el uso de SQL para extraer datos con el objetivo de ser analizados en R. library(sqldf) sqldf(&#39;SELECT age, circumference FROM Orange WHERE Tree = 1 ORDER BY circumference ASC&#39;) ## age circumference ## 1 118 30 ## 2 484 58 ## 3 664 87 ## 4 1004 115 ## 5 1231 120 ## 6 1372 142 ## 7 1582 145 4.3.3 SQL Queries El comando inicial es SELECT. SQL no es case-sensitive, por lo que esto va a funcionar: sqldf(&quot;SELECT * FROM iris&quot;) sqldf(&quot;select * from iris&quot;) pero lo siguiente no va a funcionar (a menos que tengamos un objeto IRIS: sqldf(&quot;SELECT * FROM IRIS&quot;) La sintaxis básica de SELECT es: SELECT variable1, variable2 FROM data 4.3.3.1 Asterisco/Wildcard Lo extrae todo bod2 &lt;- sqldf(&#39;SELECT * FROM BOD&#39;) 4.3.3.2 Limit Limita el número de resultados sqldf(&#39;SELECT * FROM iris LIMIT 5&#39;) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa 4.3.3.3 Order By Ordena las variables ORDER BY var1 {ASC/DESC}, var2 {ASC/DESC} sqldf(&quot;SELECT * FROM Orange ORDER BY age ASC, circumference DESC LIMIT 5&quot;) ## Tree age circumference ## 1 2 118 33 ## 2 4 118 32 ## 3 1 118 30 ## 4 3 118 30 ## 5 5 118 30 4.3.3.4 Where Sentencias condicionales, donde se puede incorporar operadores lógicos AND y OR, expresando el orden de evaluación con paréntesis en caso de ser necesario. sqldf(&#39;SELECT demand FROM BOD WHERE Time &lt; 3&#39;) ## demand ## 1 8.3 ## 2 10.3 sqldf(&#39;SELECT * FROM rock WHERE (peri &gt; 5000 AND shape &lt; .05) OR perm &gt; 1000&#39;) ## area peri shape perm ## 1 5048 941.543 0.328641 1300 ## 2 1016 308.642 0.230081 1300 ## 3 5605 1145.690 0.464125 1300 ## 4 8793 2280.490 0.420477 1300 Y extendiendo su uso con IN o LIKE (es último sólo con %), pudiendo aplicárseles el NOT: sqldf(&#39;SELECT * FROM BOD WHERE Time IN (1,7)&#39;) ## Time demand ## 1 1 8.3 ## 2 7 19.8 sqldf(&#39;SELECT * FROM BOD WHERE Time NOT IN (1,7)&#39;) ## Time demand ## 1 2 10.3 ## 2 3 19.0 ## 3 4 16.0 ## 4 5 15.6 sqldf(&#39;SELECT * FROM chickwts WHERE feed LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 179 horsebean ## 2 160 horsebean ## 3 136 horsebean ## 4 227 horsebean ## 5 217 horsebean sqldf(&#39;SELECT * FROM chickwts WHERE feed NOT LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 309 linseed ## 2 229 linseed ## 3 181 linseed ## 4 141 linseed ## 5 260 linseed "],
["introduccion-a-tecnologias-nosql.html", "Capítulo 5 Introducción a Tecnologías NoSQL 5.1 Conceptos y tipos de bases de datos NoSQL (documental, columnar, clave/valor y de grafos) 5.2 Conexión de R a NoSQL", " Capítulo 5 Introducción a Tecnologías NoSQL 5.1 Conceptos y tipos de bases de datos NoSQL (documental, columnar, clave/valor y de grafos) NoSQL - “Not Only SQL” - es una nueva categoría de bases de datos no-relacionales y altamente distribuidas. Las bases de datos NoSQL nacen de la necesidad de: Simplicidad en los diseños Escalado horizontal Mayor control en la disponibilidad Pero cuidado, en muchos escenarios las BBDD relacionales siguen siendo la mejor opción. 5.1.1 Características de las bases de datos NoSQL Libre de esquemas – no se diseñan las tablas y relaciones por adelantado, además de permitir la migración del esquema. Proporcionan replicación a través de escalado horizontal. Este escalado horizontal se traduce en arquitectura distribuida Generalmente ofrecen consistencia débil Hacen uso de estructuras de datos sencillas, normalmente pares clave/valor a bajo nivel Suelen tener un sistema de consultas propio (o SQL-like) Siguen el modelo BASE (Basic Availability, Soft state, Eventual consistency) en lugar de ACID (Atomicity, Consistency, Isolation, Durability) El modelo BASE consiste en: Basic Availability – el sistema garantiza disponibilidad, en términos del teorema CAP. Soft state – el estado del sistema puede cambiar a lo largo del tiempo, incluso sin entrada. Esto es provocado por el modelo de consistencia eventual. Eventual consistency – el sistema alcanzará un estado consistente con el tiempo, siempre y cuando no reciba entrada durante ese tiempo. 5.1.1.1 Teorema CAP Es imposible para un sistema de cómputo distribuido garantizar simultáneamente: Consistency – Todos los nodos ven los mismos datos al mismo tiempo Availability – Toda petición obtiene una respuesta en caso tanto de éxito como fallo Partition Tolerance – El sistema seguirá funcionando ante pérdidas arbitrarias de información o fallos parciales Las razones para escoger NoSQL son: Analítica Gran cantidad de escrituras, análisis en bloque Escalabilidad Tan fácil como añadir un nuevo nodo a la red, bajo coste. Redundancia Están diseñadas teniendo en cuenta la redundancia Rápido desarrollo Al ser schema-less o schema on-read son más flexibles que schema on-write Flexibilidad en el almacenamiento de datos Almacenan todo tipo de datos: texto, imágenes, BLOBs Gran rendimiento en consultas sobre datos que no implican relaciones jerárquicas Gran rendimiento sobre BBDD desnormalizadas Tamaño El tamaño del esquema de datos es demasiado grande Muchos datos temporales fuera de almacén principal Razones para NO escoger NoSQL: * Consistencia y Disponibilidad de los datos son críticas * Relaciones entre datos son importantes + E.g. joins numerosos y/o importantes * En general, cuando el modelo ACID encaja mejor 5.1.2 Tipos de Bases de Datos NoSQL 5.1.3 MongoDB: NoSQL documental 5.1.4 Redis: NoSQL key-value In-memory data structure store, útil para base de datos de login-password, sensor-valor, URL-respuesta, con una sintaxis muy sencilla: El comando SET almacena valores SET server:name “luna” Recuperamos esos valores con GET GET server:name INCR incrementa atómicamente un valor INCR clients DEL elimina claves y sus valores asociados DEL clients TTL (Time To Live) útil para cachés EXPIRE promocion 60 5.1.5 Cassandra: NoSQL columnar 5.1.6 Neo4j: NoSQL grafos 5.1.7 Otros: search engines Son sistemas especializados en búsquedas, procesamiento de lenguaje natural como ElasticSearch, Solr, Splunk (logs de aplicaciones), etc… 5.2 Conexión de R a NoSQL Step1: Install Packages plyr,XML Step2: Take xml file url Step3: create XML Internal Document type object in R using xmlParse() Step4 :Convert xml object to list by using xmlToList() Step5: convert list object to data frame by using ldply(xl, data.frame) install.packages(&quot;XML&quot;) install.packages(&quot;plyr&quot;) "],
["tecnologias-para-el-tratamiendo-de-datos-masivos.html", "Capítulo 6 Tecnologías para el Tratamiendo de Datos Masivos 6.1 Tecnologías Big Data (Hadoop, Spark, Hive, Rspark, Sparklyr) 6.2 Visualización y Generación de Cuadros de Mando 6.3 Introducción al Análisis de Datos Masivos", " Capítulo 6 Tecnologías para el Tratamiendo de Datos Masivos 6.1 Tecnologías Big Data (Hadoop, Spark, Hive, Rspark, Sparklyr) Introducción a los conceptos básicos del ecosistema Hadoop 6.2 Visualización y Generación de Cuadros de Mando 6.3 Introducción al Análisis de Datos Masivos "]
]
