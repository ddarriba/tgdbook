[
["index.html", "Prácticas de Tecnologías de Gestión de Datos Prólogo", " Prácticas de Tecnologías de Gestión de Datos Rubén F. Casal (ruben.fcasal@udc.es), Guillermo López Taboada (guillermo.lopez.taboada@udc.es) 2019-09-08 Prólogo Este libro contiene algunas de las prácticas de la asignatura de Tecnologías de Gestión de Datos del Máster interuniversitario en Técnicas Estadísticas). Este libro ha sido escrito en R-Markdown empleando el paquete bookdown y está disponible en el repositorio Github: rubenfcasal/simbook. Para generar el libro (compilar) puede ser recomendable instalar la última versión de RStudio y la versión de desarrollo de bookdown disponible en Github: devtools::install_github(&quot;rstudio/bookdown&quot;) Este obra está bajo una licencia de Creative Commons Reconocimiento-NoComercial-SinObraDerivada 4.0 Internacional (espero poder liberarlo bajo una licencia menos restrictiva más adelante…). "],
["introduccion-a-las-tecnologias-de-gestion-de-datos.html", "Capítulo 1 Introducción a las Tecnologías de Gestión de Datos 1.1 Introducción 1.2 Generación de números (pseudo)aleatorios 1.3 Números aleatorios puros 1.4 Números pseudoaleatorios", " Capítulo 1 Introducción a las Tecnologías de Gestión de Datos 1.1 Introducción Problemas de la experimentación directa sobre la realidad: Coste elevado. En ocasiones las pruebas son destructivas. Lentitud. Puede no ser ética. experimentación sobre seres humanos. Puede resultar imposible. Acontecimientos futuros, … … Puede ser preferible trabajar con un modelo del sistema real. La realidad puede ser muy compleja por lo que es habitual emplear un modelo para tratar de explicarla: Modelos deterministas. Modelos estocásticos (con componente aleatoria). Cuando no se dispone de la suficiente información sobre las variables que influyen en el fenómeno en estudio. Se tienen en cuenta esta incertidumbre. La inferencia estadística proporciona herramientas para estimar los parámetros y contrastar la validez de un modelo estocástico a partir de los datos observados. La idea es emplear el modelo para resolver el problema de interés. Cuando la solución no se puede obtener de modo analítico (teórico) se puede recurrir a la simulación. Simulación: realizar experimentos con un modelo con el objetivo de recopilar información bajo determinadas condiciones. Nos centraremos en el caso de la simulación estocástica: Las conclusiones se obtienen habitualmente generando repetidamente simulaciones del modelo aleatorio. 1.1.1 Ventajas de la simulación (Shannon, 1975): Cuando la resolución analítica no puede llevarse a cabo. Cuando existen medios de resolver analíticamente el problema pero dicha resolución es complicada y costosa (o solo proporciona una solución aproximada). Si se desea experimentar antes de que exista el sistema (pruebas para la construcción de un sistema). Cuando es imposible experimentar sobre el sistema real por ser dicha experimentación destructiva. En ocasiones en las que la experimentación sobre el sistema es posible pero no ética. En sistemas que evolucionan muy lentamente en el tiempo. 1.1.2 Inconvenientes de la simulación: La construcción de un buen modelo puede ser una tarea muy costosa (compleja, laboriosa y requerir mucho tiempo; e.g. modelos climáticos). Frecuentemente el modelo omite variables o relaciones importantes entre ellas (los resultados pueden no ser válidos para el sistema real). Resulta difícil conocer la precisión de la simulación (especialmente en lo relativo a la precisión del modelo formulado). Problemas de extrapolación de las conclusiones. Tiempo de computación. 1.2 Generación de números (pseudo)aleatorios Aplicaciones: Estadística: Muestreo, remuestreo, … Aproximación de distribuciones (de estadísticos, estimadores, …) Realización de contrastes, intervalos de confianza, … Comparación de estimadores, contrastes, … Validación teoría (distribución asintótica,…) Inferencia Bayesiana Optimización: Algoritmos genéticos, … Computación: Diseño, verificación y validación de algoritmos,… Criptografía: Protocolos de comunicación segura, … Física: Simulación de fenómenos naturales, … Análisis numérico: Evaluación de expresiones, … … En el Capítulo XX nos centraremos en algunas de las aplicaciones de utilidad en Estadística. 1.3 Números aleatorios puros Una sucesión de números aleatorios puros (true random), se caracteriza por que no existe ninguna regla o plan que nos permita conocer sus valores. Se almacena(ban) en tablas de dígitos aleatorios (true random) y normalmente son obtenidos por procesos físicos (loterías, ruletas, ruidos,…) Se emplean para seleccionar números aleatorios en un rango de 1 a m: Se selecciona al azar un pto de inicio en la tabla y una dirección. Se agrupan los dígitos de forma que “cubran” el valor de m. Se seleccionan los valores menores o iguales que m (se descarta el resto). Algunos enlaces: A Million Random Digits with 100,000 Normal Deviates . RAND Corporation. 1955. Generadores de números aleatorios “online”: http://www.random.org/integers (ver paquete random en R). http://www.fourmilab.ch/hotbits Generadores mediante hardware: http://software.intel.com. http://spectrum.ieee.org Sus principales aplicaciones hoy en día son en criptografía (impredictibilidad). 1.3.1 Inconvenientes: Es necesario/recomendable conocer su distribución. Los datos generados deberían ser i.i.d. Reproductivilidad. Pueden requerir del almacenamiento en tablas. 1.3.2 Alternativas: números pseudo-aleatorios: simulan realizaciones de una variable aleatoria (uniforme). números cuasi-aleatorios: secuencias determinísticas con una distribución más uniforme en el rango considerado (se podría pensar que son una única generación de una variable aleatoria). 1.4 Números pseudoaleatorios 1.4.1 Generación de números pseudoaleatorios mediante software La mayoría de los métodos de simulación se basan en la posibilidad de generar números pseudoaleatorios con distribución \\(\\mathcal{U}(0,1)\\). Se obtienen mediante un algoritmo recursivo denominado generador: \\[x_{i}=f\\left( x_{i-1},x_{i-2},\\cdots,x_{i-k}\\right)\\] \\(k\\) orden del generador. \\(\\left( x_{0},x_{1},\\cdots,x_{k-1}\\right)\\) semilla (estado inicial). El periodo o longitud del ciclo es la longitud de la secuencia antes de que vuelva a repetirse. Lo denotaremos por \\(p\\). Los números de la sucesión serán predecibles, conociendo el algoritmo y la semilla. Sin embargo, si no se conociesen, no se debería poder distinguir una serie de números pseudoaleatorios de una sucesión de números verdaderamente aleatoria (utilizando recursos computacionales razonables). En caso contrario esta predecibilidad puede dar lugar a serios problemas (e.g. http://eprint.iacr.org/2007/419). Como regla general, por lo menos mientras se está desarrollando un programa, interesa fijar la semilla de aleatorización. Permite la reproductibilidad de los resultados. Facilita la depuración del código. Todo generador de números pseudoaleatorios mínimamente aceptable debe comportarse como si se tratase de una muestra genuina de datos independientes de una \\(\\mathcal{U}(0,1)\\). Otras propiedades de interés serían: Reproducibilidad a partir de la semilla. Periodo suficientemente largo. Eficiencia (rapidez y requerimientos de memoria). Portabilidad. Generación de sub-secuencias (computación en paralelo). Parsimonia, … Gran cantidad de algoritmos: Cuadrados medios, Lehmer,… Congruenciales Registros desfasados Combinaciones … Código fuente disponible en múltiples librerias: GNU Scientific Library (GSL): http://www.gnu.org/software/gsl/manual StatLib: http://lib.stat.cmu.edu Numerical recipes: http://www.nrbook.com/nr3 http://random.mat.sbg.ac.at/software KISS (Keep It Simple Stupid / Small and Simple): http://www.fortran.com/kiss.f90 UNU.RAN (paquete Runuran): http://statmath.wu.ac.at/unuran … Nos centraremos en los generadores congruenciales, descritos en la [Sección 3.1][Generadores congruenciales]. "],
["sql-en-r.html", "Capítulo 2 SQL en R 2.1 Introducción a SQL", " Capítulo 2 SQL en R 2.1 Introducción a SQL SQL (Structured Query Language) … Paquetes: [DBI] (https://cran.r-project.org/web/packages/DBI/index.html) RODBC dbConnect RSQLite RMySQL RPostgreSQL aunque el básico sqldf library(sqldf) sqldf(&#39;SELECT age, circumference FROM Orange WHERE Tree = 1 ORDER BY circumference ASC&#39;) ## age circumference ## 1 118 30 ## 2 484 58 ## 3 664 87 ## 4 1004 115 ## 5 1231 120 ## 6 1372 142 ## 7 1582 145 2.1.1 SQL Queries El comando inicial es SELECT. SQL no es case-sensitive, por lo que esto va a funcionar: sqldf(&quot;SELECT * FROM iris&quot;) sqldf(&quot;select * from iris&quot;) pero lo siguiente no va a funcionar (a menos que tengamos un objeto IRIS: sqldf(&quot;SELECT * FROM IRIS&quot;) La sintaxis básica de SELECT es: SELECT variable1, variable2 FROM data 2.1.1.1 Asterisco/Wildcard Lo extrae todo bod2 &lt;- sqldf(&#39;SELECT * FROM BOD&#39;) 2.1.1.2 Limit Limita el número de resultados sqldf(&#39;SELECT * FROM iris LIMIT 5&#39;) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa 2.1.1.3 Order By Ordena las variables ORDER BY var1 {ASC/DESC}, var2 {ASC/DESC} sqldf(&quot;SELECT * FROM Orange ORDER BY age ASC, circumference DESC LIMIT 5&quot;) ## Tree age circumference ## 1 2 118 33 ## 2 4 118 32 ## 3 1 118 30 ## 4 3 118 30 ## 5 5 118 30 2.1.1.4 Where Sentencias condicionales, donde se puede incorporar operadores lógicos AND y OR, expresando el orden de evaluación con paréntesis en caso de ser necesario. sqldf(&#39;SELECT demand FROM BOD WHERE Time &lt; 3&#39;) ## demand ## 1 8.3 ## 2 10.3 sqldf(&#39;SELECT * FROM rock WHERE (peri &gt; 5000 AND shape &lt; .05) OR perm &gt; 1000&#39;) ## area peri shape perm ## 1 5048 941.543 0.328641 1300 ## 2 1016 308.642 0.230081 1300 ## 3 5605 1145.690 0.464125 1300 ## 4 8793 2280.490 0.420477 1300 Y extendiendo su uso con IN o LIKE (es último sólo con %), pudiendo aplicárseles el NOT: sqldf(&#39;SELECT * FROM BOD WHERE Time IN (1,7)&#39;) ## Time demand ## 1 1 8.3 ## 2 7 19.8 sqldf(&#39;SELECT * FROM BOD WHERE Time NOT IN (1,7)&#39;) ## Time demand ## 1 2 10.3 ## 2 3 19.0 ## 3 4 16.0 ## 4 5 15.6 sqldf(&#39;SELECT * FROM chickwts WHERE feed LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 179 horsebean ## 2 160 horsebean ## 3 136 horsebean ## 4 227 horsebean ## 5 217 horsebean sqldf(&#39;SELECT * FROM chickwts WHERE feed NOT LIKE &quot;%bean&quot; LIMIT 5&#39;) ## weight feed ## 1 309 linseed ## 2 229 linseed ## 3 181 linseed ## 4 141 linseed ## 5 260 linseed "],
["introduccion-a-tecnologias-nosql.html", "Capítulo 3 Introducción a Tecnologías NoSQL 3.1 Conceptos y tipos de bases de datos NoSQL (documental, columnar, clave/valor y de grafos) 3.2 Conexión de R a NoSQL", " Capítulo 3 Introducción a Tecnologías NoSQL 3.1 Conceptos y tipos de bases de datos NoSQL (documental, columnar, clave/valor y de grafos) NoSQL - “Not Only SQL” - es una nueva categoría de bases de datos no-relacionales y altamente distribuidas. Las bases de datos NoSQL nacen de la necesidad de: Simplicidad en los diseños Escalado horizontal Mayor control en la disponibilidad Pero cuidado, en muchos escenarios las BBDD relacionales siguen siendo la mejor opción. 3.1.1 Características de las bases de datos NoSQL Libre de esquemas – no se diseñan las tablas y relaciones por adelantado, además de permitir la migración del esquema. Proporcionan replicación a través de escalado horizontal. Este escalado horizontal se traduce en arquitectura distribuida Generalmente ofrecen consistencia débil Hacen uso de estructuras de datos sencillas, normalmente pares clave/valor a bajo nivel Suelen tener un sistema de consultas propio (o SQL-like) Siguen el modelo BASE (Basic Availability, Soft state, Eventual consistency) en lugar de ACID (Atomicity, Consistency, Isolation, Durability) El modelo BASE consiste en: Basic Availability – el sistema garantiza disponibilidad, en términos del teorema CAP. Soft state – el estado del sistema puede cambiar a lo largo del tiempo, incluso sin entrada. Esto es provocado por el modelo de consistencia eventual. Eventual consistency – el sistema alcanzará un estado consistente con el tiempo, siempre y cuando no reciba entrada durante ese tiempo. 3.1.1.1 Teorema CAP Es imposible para un sistema de cómputo distribuido garantizar simultáneamente: Consistency – Todos los nodos ven los mismos datos al mismo tiempo Availability – Toda petición obtiene una respuesta en caso tanto de éxito como fallo Partition Tolerance – El sistema seguirá funcionando ante pérdidas arbitrarias de información o fallos parciales Las razones para escoger NoSQL son: Analítica Gran cantidad de escrituras, análisis en bloque Escalabilidad Tan fácil como añadir un nuevo nodo a la red, bajo coste. Redundancia Están diseñadas teniendo en cuenta la redundancia Rápido desarrollo Al ser schema-less o schema on-read son más flexibles que schema on-write Flexibilidad en el almacenamiento de datos Almacenan todo tipo de datos: texto, imágenes, BLOBs Gran rendimiento en consultas sobre datos que no implican relaciones jerárquicas Gran rendimiento sobre BBDD desnormalizadas Tamaño El tamaño del esquema de datos es demasiado grande Muchos datos temporales fuera de almacén principal Razones para NO escoger NoSQL: * Consistencia y Disponibilidad de los datos son críticas * Relaciones entre datos son importantes + E.g. joins numerosos y/o importantes * En general, cuando el modelo ACID encaja mejor 3.1.2 Tipos de Bases de Datos NoSQL 3.1.3 MongoDB: NoSQL documental 3.1.4 Redis: NoSQL key-value In-memory data structure store, útil para base de datos de login-password, sensor-valor, URL-respuesta, con una sintaxis muy sencilla: El comando SET almacena valores SET server:name “luna” Recuperamos esos valores con GET GET server:name INCR incrementa atómicamente un valor INCR clients DEL elimina claves y sus valores asociados DEL clients TTL (Time To Live) útil para cachés EXPIRE promocion 60 3.1.5 Cassandra: NoSQL columnar 3.1.6 Neo4j: NoSQL grafos 3.1.7 Otros: search engines Son sistemas especializados en búsquedas, procesamiento de lenguaje natural como ElasticSearch, Solr, Splunk (logs de aplicaciones), etc… 3.2 Conexión de R a NoSQL Step1: Install Packages plyr,XML Step2: Take xml file url Step3: create XML Internal Document type object in R using xmlParse() Step4 :Convert xml object to list by using xmlToList() Step5: convert list object to data frame by using ldply(xl, data.frame) install.packages(&quot;XML&quot;) install.packages(&quot;plyr&quot;) "]
]
